@namespace CloudStreams.Dashboard.Components
@using CloudStreams.Dashboard.Components.TimelineStateManagement
@inherits StatefulComponent<TimelineStore, TimelineState>
@inject EventDropsInterop EventDropsInterop
@implements IAsyncDisposable;

<div class="overflow-auto h-100">
    @if (streamsReadOptions != null)
    {
        <div class="mb-3">
            @for(int i = 0, c = streamsReadOptions.Count(); i<c; i++)
            {
                int optionIndex = i;
                <div class="d-flex">
                    <ReadOptionsForm OnChange="(readOptions) => Store.SetStreamsReadOption(optionIndex, readOptions)"></ReadOptionsForm>
                    <Button class="ms-3 mb-3" Color="ButtonColor.Danger" Outline="true" @onclick="_ => Store.RemoveStreamsReadOption(optionIndex)" Disabled="loading"><Icon Name="IconName.Dash"></Icon></Button>
                </div>
            }

            <div class="d-flex justify-content-between">
                <Button Color="ButtonColor.Primary" Outline="true" @onclick="async _ => await Store.GatherCloudEventsAsync()" Disabled="loading" Loading="loading">Refresh</Button>
                <Button Color="ButtonColor.Light" Outline="true" @onclick="_ => Store.AddStreamsReadOption()" Disabled="loading"><Icon Name="IconName.Plus"></Icon></Button>
            </div>
        </div>
    }

    <div @ref="timeline"></div>
</div>

<div @ref="tooltip" class="timeline-tooltip card" style="@(tooltipStyle)">
    @if (cloudEvent != null)
    {
        <div class="card-header text-primary">
            @cloudEvent.Time!.Value.ToString("R")
        </div>
        <div class="card-body">
            <table class="table table-sm table-striped">
                <tbody>
                    <tr>
                        <td>Id</td>
                        <td>@cloudEvent.Id</td>
                    </tr>
                    <tr>
                        <td>Source</td>
                        <td>@cloudEvent.Source</td>
                    </tr>
                    <tr>
                        <td>Type</td>
                        <td>@cloudEvent.Type</td>
                    </tr>
                    @if (!string.IsNullOrWhiteSpace(cloudEvent.Subject))
                    {
                        <tr>
                            <td>Subject</td>
                            <td>@cloudEvent.Subject</td>
                        </tr>
                    }
                    <tr>
                        <td>Spec. Version</td>
                        <td>@cloudEvent.SpecVersion</td>
                    </tr>
                    @if (cloudEvent.DataSchema != null)
                    {
                        <tr>
                            <td>Data Schema</td>
                            <td>@cloudEvent.DataSchema</td>
                        </tr>
                    }
                    @if (!string.IsNullOrWhiteSpace(cloudEvent.DataContentType))
                    {
                        <tr>
                            <td>Data Content Type</td>
                            <td>@cloudEvent.DataContentType</td>
                        </tr>
                    }
                    @if (cloudEvent != null && cloudEvent.ExtensionAttributes?.Any() == true)
                    {
                        @foreach (var attr in cloudEvent.ExtensionAttributes)
                        {
                            <tr>
                                <td>@attr.Key.ToPascalCase()</td>
                                <td>@attr.Value</td>
                            </tr>
                        }
                    }
                </tbody>
            </table>
            @if (cloudEvent.Data != null)
            {
                <pre>
                    @Serializer.Json.Serialize(cloudEvent.Data, true)
                </pre>
            }
        </div>
    }
</div>

@code {
    /// <summary>
    /// A reference to the DOM element of the timeline
    /// </summary>
    private ElementReference timeline;
    /// <summary>
    /// A reference to the DOM element of the timeline's tooltip
    /// </summary>
    private ElementReference tooltip;
    /// <summary>
    /// A Dotnet reference of the current component, used for interop
    /// </summary>
    private DotNetObjectReference<Timeline>? dotnetReference = null;
    /// <summary>
    /// A javascript reference of the current component, used for interop
    /// </summary>
    //private IJSObjectReference? jsReference = null;
    /// <summary>
    /// Indicates whether or not the componenet has been disposed
    /// </summary>
    private bool disposed = false;
    /// <summary>
    /// The list of <see cref="StreamReadOptions"/> used to populate <see cref="TimelineLane"/>s
    /// </summary>
    private IEnumerable<StreamReadOptions>? streamsReadOptions = null;
    /// <summary>
    /// The list of <see cref="TimelineLane"/> to build the <see cref="Timeline"/> with
    /// </summary>
    private IEnumerable<TimelineLane>? timelineLanes = null;
    /// <summary>
    /// The indicator of the data is being gathered
    /// </summary>
    private bool loading = false;
    /// <summary>
    /// The style applied to the tooltip
    /// </summary>
    private string tooltipStyle = "";
    /// <summary>
    /// The cloud event displayed in the tooltip
    /// </summary>
    private CloudEvent? cloudEvent = null;

    /// <inheritdoc/>
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync().ConfigureAwait(false);
        this.Store.StreamsReadOptions.Subscribe(streamsReadOptions => this.OnStateChanged(cmp => cmp.streamsReadOptions = streamsReadOptions), token: this.CancellationTokenSource.Token);
        this.Store.Loading.Subscribe(processing => this.OnStateChanged(cmp => cmp.loading = processing), token: this.CancellationTokenSource.Token);
        this.Store.TimelineLanes.SubscribeAsync(async timelineLanes => await this.RenderTimelineAsync(timelineLanes), cancellationToken: this.CancellationTokenSource.Token);
    }

    /// <inheritdoc/>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            this.dotnetReference = DotNetObjectReference.Create(this);
            await Store.GatherCloudEventsAsync();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    /// <summary>
    /// Renders the timeline with the provided <see cref="TimelineLane"/>s
    /// </summary>
    /// <param name="timelineLanes">The <see cref="TimelineLane"/>s to render</param>
    private async Task RenderTimelineAsync(IEnumerable<TimelineLane> timelineLanes)
    {
        if (timelineLanes == null && !timelineLanes.Any())
        {
            return;
        }
        var entries = timelineLanes.SelectMany(lane => lane.Data).OrderBy(data => data.Time!.Value);
        if (!entries.Any())
        {
            return;
        }
        var start = entries.First().Time!.Value;
        var end = entries.Last().Time!.Value;
        var margin = end.Subtract(start).TotalMilliseconds / 20;
        await this.EventDropsInterop.RenderTimelineAsync(this.timeline, this.dotnetReference, timelineLanes, start, end.AddMilliseconds(margin));
    }

    /// <summary>
    /// Patches the <see cref="Timeline"/>'s fields after a <see cref="TimelineStore"/>'s change
    /// </summary>
    /// <param name="patch">The patch to apply</param>
    private void OnStateChanged(Action<Timeline> patch)
    {
        patch(this);
        this.StateHasChanged();
    }

    /// <summary>
    /// Shows the tooltip for the provided <see cref="CloudEvent"/>
    /// </summary>
    /// <param name="cloudEvent">The <see cref="CloudEvent"/> to display</param>
    /// <param name="x">The position of the tooltip on the x-axis</param>
    /// <param name="y">The position of the tooltip on the y-axis</param>
    [JSInvokable]
    public void ShowTooltipOnMouseOver(CloudEvent cloudEvent, int x, int y)
    {
        this.cloudEvent = cloudEvent;
        this.tooltipStyle = $"opacity: 1; left: calc({x}px - 1rem); top: calc({y}px + 1rem)";
        this.StateHasChanged();
    }

    /// <summary>
    /// Hides the tooltip
    /// </summary>
    [JSInvokable]
    public void HideTooltipOnMouseOut()
    {
        this.tooltipStyle = "opacity: 0;";
        this.cloudEvent = null;
        this.StateHasChanged();
    }

    /// <inheritdoc/>
    public async ValueTask DisposeAsync()
    {
        if (!this.disposed)
        {
            //if (this.jsReference != null)
            //{
            //    await this.jsReference.InvokeVoidAsync("disconnect");
            //    await this.jsReference.DisposeAsync();
            //    this.jsReference = null;
            //}
            if (this.dotnetReference != null)
            {
                this.dotnetReference.Dispose();
                this.dotnetReference = null;
            }
            this.disposed = true;
        }
    }

}
