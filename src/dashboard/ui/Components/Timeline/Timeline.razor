@namespace CloudStreams.Dashboard.Components
@using CloudStreams.Dashboard.Components.TimelineStateManagement
@inherits StatefulComponent<TimelineStore, TimelineState>
@inject EventDropsInterop EventDropsInterop
@implements IAsyncDisposable;


<div @ref="timeline"></div>

@code {
    /// <summary>
    /// A reference to the DOM element of the timeline
    /// </summary>
    private ElementReference timeline;
    /// <summary>
    /// A Dotnet reference of the current component, used for interop
    /// </summary>
    private DotNetObjectReference<Timeline>? dotnetReference = null;
    /// <summary>
    /// A javascript reference of the current component, used for interop
    /// </summary>
    private IJSObjectReference? jsReference = null;
    /// <summary>
    /// Indicates whether or not the componenet has been disposed
    /// </summary>
    private bool disposed;
    /// <summary>
    /// The list of <see cref="StreamReadOptions"/> used to populate <see cref="TimelineLane"/>s
    /// </summary>
    private IEnumerable<StreamReadOptions> streamsReadOptions;
    /// <summary>
    /// The list of <see cref="TimelineLane"/> to build the <see cref="Timeline"/> with
    /// </summary>
    private IEnumerable<TimelineLane> timelineLanes;
    /// <summary>
    /// The indicator of the data is being gathered
    /// </summary>
    private bool processing;

    /// <inheritdoc/>
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync().ConfigureAwait(false);
        this.Store.StreamsReadOptions.Subscribe(streamsReadOptions => this.OnStateChanged(state => state.streamsReadOptions = streamsReadOptions), token: this.CancellationTokenSource.Token);
        this.Store.Processing.Subscribe(processing => this.OnStateChanged(state => state.processing = processing), token: this.CancellationTokenSource.Token);
        this.Store.TimelineLanes.SubscribeAsync(async timelineLanes => await this.RenderTimelineAsync(timelineLanes), cancellationToken: this.CancellationTokenSource.Token);
    }

    private async Task RenderTimelineAsync(IEnumerable<TimelineLane> timelineLanes)
    {
        var entries = timelineLanes.SelectMany(lane => lane.Data).OrderBy(data => data.Date);
        await this.EventDropsInterop.RenderTimelineAsync(this.timeline, timelineLanes, entries.First().Date, entries.Last().Date);
    }
    /// <summary>
    /// Patches the <see cref="Timeline"/>'s fields after a <see cref="TimelineStore"/>'s change
    /// </summary>
    /// <param name="patch">The patch to apply</param>
    private void OnStateChanged(Action<Timeline> patch)
    {
        patch(this);
        this.StateHasChanged();
    }

    /// <inheritdoc/>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            this.dotnetReference = DotNetObjectReference.Create(this);
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    /// <inheritdoc/>
    public async ValueTask DisposeAsync()
    {
        if (!this.disposed)
        {
            if (this.jsReference != null)
            {
                await this.jsReference.InvokeVoidAsync("disconnect");
                await this.jsReference.DisposeAsync();
                this.jsReference = null;
            }
            if (this.dotnetReference != null)
            {
                this.dotnetReference.Dispose();
                this.dotnetReference = null;
            }
            this.disposed = true;
        }
    }

}
