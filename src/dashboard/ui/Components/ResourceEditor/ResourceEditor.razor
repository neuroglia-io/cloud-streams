@namespace CloudStreams.Dashboard.Components
@using CloudStreams.Dashboard.Components.ResourceEditorStateManagement
@using CloudStreams.Dashboard.StateManagement
@typeparam TResource where TResource : class, IResource, new()
@inherits StatefulComponent<ResourceEditorStore<TResource>, ResourceEditorState<TResource>>
@inject IMonacoEditorHelper MonacoEditorHelper

<div class="container-fluid d-flex flex-grow flex-column">
    <div class="row flex-grow">
        <PreferedLanguageSelector PreferedLanguageChange="ToggleTextBasedEditorLanguageAsync" />
        <StandaloneCodeEditor @ref="textBasedEditor"
            ConstructionOptions="MonacoEditorHelper.GetStandaloneEditorConstructionOptions(this.textEditorValue, false, this.MonacoEditorHelper.PreferedLanguage)"
            OnDidInit="OnTextBasedEditorInit"
            OnDidChangeModelContent="OnTextBasedValueChanged" />
        @if (errors != null && errors.Any())
        {
            foreach (KeyValuePair<string, string[]> errorContainer in errors)
            {
                <Callout Type="CalloutType.Danger" Heading="@errorContainer.Key">
                    <ul>
                        @foreach (string error in errorContainer.Value)
                        {
                            <li>@error</li>
                        }
                    </ul>
                </Callout>
            }
        }
        <Button Color="ButtonColor.Primary" Outline="true" Disabled="updating || saving" Loading="saving" @onclick="async _ => await Store.UpdateResourceAsync()">Update</Button>
    </div>
</div>

@code {

    TResource? resource;
    /// <summary>
    /// Gets/sets the resource to display details about
    /// </summary>
    [Parameter] public TResource? Resource { get; set; }

    /// <summary>
    /// The reference of the <see cref="StandaloneCodeEditor" />
    /// </summary>
    private StandaloneCodeEditor? textBasedEditor;

    /// <summary>
    /// The <see cref="Subject" /> used to observe and debounce the input of the text editor
    /// </summary>
    private Subject<string> textEditorInput = new Subject<string>();

    /// <summary>
    /// The content of the text editor
    /// </summary>
    private string textEditorValue = string.Empty;

    /// <summary>
    /// The <see cref="TextModel" /> provided to the <see cref="StandaloneCodeEditor" />
    /// </summary>
    private TextModel? textEditorModel = null!;

    /// <summary>
    /// A boolean indicating if the text editor is being updated
    /// </summary>
    private bool updating = false;

    /// <summary>
    /// A boolean indicating if the resource is being saved
    /// </summary>
    private bool saving = false;

    /// <summary>
    ///The list of errors that occured when trying to save the resource, if any
    /// </summary>
    private IDictionary<string, string[]> errors = new Dictionary<string, string[]>();

    /// <inheritdoc/>
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync().ConfigureAwait(false);
        this.Store.Resource.Subscribe(resource => this.OnStateChanged(state => state.resource = resource), token: this.CancellationTokenSource.Token);
        this.Store.Updating.Subscribe(updating => this.OnStateChanged(state => state.updating = updating), token: this.CancellationTokenSource.Token);
        this.Store.Saving.Subscribe(saving => this.OnStateChanged(state => state.saving = saving), token: this.CancellationTokenSource.Token);
        this.Store.Errors.Subscribe(errors => this.OnStateChanged(state => state.errors = errors), token: this.CancellationTokenSource.Token);
        this.textEditorInput
            .Throttle(TimeSpan.FromMilliseconds(300))
            .DistinctUntilChanged()
            .Subscribe(text => this.Store.SetEditorValue(text));
        this.Store.TextEditorValue.SubscribeAsync(async textEditorValue =>
        {
            this.textEditorValue = textEditorValue;
            await this.SetTextEditorValueAsync();
        }, cancellationToken: this.CancellationTokenSource.Token);
    }

    /// <inheritdoc/>
    protected override Task OnParametersSetAsync()
    {
        if (this.resource != this.Resource)
        {
            this.resource = this.Resource;
            this.Store.SetResource(this.Resource);
        }
        return base.OnParametersSetAsync();
    }

    /// <summary>
    /// Patches the <see cref="ResourceEditor{TResource}"/>'s fields after a <see cref="ResourceEditorStore{TResource}"/>'s change
    /// </summary>
    /// <param name="patch">The patch to apply</param>
    private void OnStateChanged(Action<ResourceEditor<TResource>> patch)
    {
        patch(this);
        this.StateHasChanged();
    }

    /// <summary>
    /// Handles the <see cref="Editor.OnDidInit" /> event
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    private async Task OnTextBasedEditorInit()
    {
        string resourceUri = $"inmemory://{typeof(TResource).Name.ToLower()}";
        this.textEditorModel = await Global.GetModel(resourceUri);
        if (this.textEditorModel == null)
        {
            this.textEditorModel = await Global.CreateModel(this.textEditorValue, this.MonacoEditorHelper.PreferedLanguage, resourceUri);
            await this.textBasedEditor!.SetModel(this.textEditorModel);
        }
        else
        {
            await this.SetTextEditorValueAsync();
            await this.SetTextBasedEditorLanguageAsync();
        }
        this.StateHasChanged();
    }

    /// <summary>
    /// Handles the <see cref="CodeEditor.OnDidChangeModelContent" /> event
    /// </summary>
    /// <param name="e">The source <see cref="ModelContentChangedEvent" /></param>
    /// <returns>A <see cref="Task"/></returns>
    private async Task OnTextBasedValueChanged(ModelContentChangedEvent e)
    {
        if (!this.updating && this.textBasedEditor != null && this.textEditorInput != null)
        {
            string text = await this.textBasedEditor.GetValue();
            this.textEditorInput.OnNext(text);
        }
    }

    /// <summary>
    /// Changes the editor's text
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    private async Task SetTextEditorValueAsync()
    {
        if (this.textBasedEditor != null)
        {
            string editorText = await this.textBasedEditor.GetValue();
            if (this.textEditorValue != editorText)
            {
                await this.textBasedEditor.SetValue(this.textEditorValue);
            }
        }
    }

    /// <summary>
    /// Changes the editor's language
    /// </summary>
    /// <returns>A <see cref="Task"/></returns>
    private async Task SetTextBasedEditorLanguageAsync()
    {
        if (this.textBasedEditor != null && this.textEditorModel != null)
        {
            //TextModel model = await this.textBasedEditor!.GetModel();
            await Global.SetModelLanguage(this.textEditorModel, this.MonacoEditorHelper.PreferedLanguage);
        }
    }

    /// <summary>
    /// Changes the editor language
    /// </summary>
    /// <param name="language">The new editor's language</param>
    /// <returns>A <see cref="Task"/></returns>
    private async Task ToggleTextBasedEditorLanguageAsync(string language)
    {

        TextModel model = await this.textBasedEditor!.GetModel();
        string editorLanguage = await model.GetLanguageId();
        if (editorLanguage != language)
        {
            await this.Store.ChangeTextEditorLanguageAsync(language);
            await this.SetTextBasedEditorLanguageAsync();
        }
    }

    private bool _Disposed;
    /// <summary>
    /// Disposes of the component
    /// </summary>
    /// <param name="disposing">A boolean indicating whether or not the dispose of the component</param>
    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        if (!this._Disposed)
        {
            if (disposing)
            {
                if (this.textEditorInput != null)
                {
                    this.textEditorInput.Dispose();
                    this.textEditorInput = null;
                }
                if (this.textEditorModel != null)
                {
                    this.textEditorModel.DisposeModel();
                    this.textEditorModel = null;
                }
                if (this.textBasedEditor != null)
                {
                    this.textBasedEditor.Dispose();
                    this.textBasedEditor = null;
                }
            }
            this._Disposed = true;
        }
    }

}
